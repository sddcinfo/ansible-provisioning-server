#!/usr/bin/env python3

# =================================================================================
# A self-contained Python script to send Redfish commands to server nodes.
#
# This script is dynamically generated by an Ansible playbook to ensure it is
# always in sync with the inventory. It uses only standard Python 3 libraries.
# =================================================================================

import argparse
import json
import os
import ssl
import sys
from urllib import request, error
import base64

# --- Configuration ---
# This list is dynamically generated by Ansible.
CONSOLE_NODES = {{ console_nodes | to_json }}
CREDENTIALS_FILE = os.path.expanduser("~/.redfish_credentials")
# --- End Configuration ---


def get_node_ip(node_name):
    """Finds the IP address for a given node hostname."""
    for node in CONSOLE_NODES:
        if node.get("hostname") == node_name:
            return node.get("ip")
    return None


def get_redfish_credentials():
    """Reads and decodes the Basic Auth string from the credentials file."""
    if not os.path.exists(CREDENTIALS_FILE):
        print(f"Error: Credentials file not found at {CREDENTIALS_FILE}", file=sys.stderr)
        sys.exit(1)
    if os.stat(CREDENTIALS_FILE).st_mode & 0o077 != 0:
        print(f"Error: Credentials file ({CREDENTIALS_FILE}) has insecure permissions. Please set to 600.", file=sys.stderr)
        sys.exit(1)
    with open(CREDENTIALS_FILE, 'r') as f:
        content = f.read().strip()
        # Expecting format: REDFISH_AUTH="username:password"
        if content.startswith('REDFISH_AUTH="') and content.endswith('"'):
            user_pass = content.split('"')[1]
            # Base64 encode the user:pass string for the Authorization header
            return base64.b64encode(user_pass.encode('utf-8')).decode('utf-8')
    print(f"Error: Could not parse REDFISH_AUTH in {CREDENTIALS_FILE}", file=sys.stderr)
    sys.exit(1)


def main():
    """Main function to parse arguments and execute Redfish command."""
    # Dynamically generate choices for the node argument from the CONSOLE_NODES list
    node_choices = [node['hostname'] for node in CONSOLE_NODES]
    
    parser = argparse.ArgumentParser(
        description="A script to send Redfish commands to server nodes.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("node", choices=node_choices, help="The target node name.")
    parser.add_argument(
        "action",
        choices=[
            "status", "power-on", "power-off", "power-force-off",
            "reboot", "bios", "pxe", "disk"
        ],
        help="""The action to perform:
  status           : Get system power state and health status.
  power-on         : Powers the system on.
  power-off        : Powers the system off gracefully.
  power-force-off  : Forces the system to power off immediately.
  reboot           : Performs a force restart of the node.
  bios             : Sets the node to boot into BIOS setup on next restart.
  pxe              : Sets the node to boot from PXE on next restart.
  disk             : Sets the node to boot from the default disk on next restart."""
    )
    args = parser.parse_args()

    # --- Get Node IP ---
    ip = get_node_ip(args.node)
    if not ip:
        # This should not happen if the script is generated correctly
        print(f"Error: Node '{args.node}' not found. Was this script generated correctly?", file=sys.stderr)
        sys.exit(1)

    # --- Get Credentials ---
    auth_header = f"Basic {get_redfish_credentials()}"

    # --- Define Action ---
    base_url = f"https://{ip}/redfish/v1/Systems/1"
    url_path = ""
    http_method = "GET"
    payload = None

    actions = {
        "status": {"method": "GET"},
        "power-on": {"path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "On"}},
        "power-off": {"path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "GracefulShutdown"}},
        "power-force-off": {"path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "ForceOff"}},
        "reboot": {"path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "ForceRestart"}},
        "bios": {"method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "BiosSetup", "BootSourceOverrideEnabled": "Once"}}},
        "pxe": {"method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "Pxe", "BootSourceOverrideEnabled": "Once"}}},
        "disk": {"method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "Hdd", "BootSourceOverrideEnabled": "Once"}}},
    }

    action_details = actions.get(args.action)
    http_method = action_details.get("method", "POST")
    url_path = action_details.get("path", "")
    if "payload" in action_details:
        payload = json.dumps(action_details["payload"]).encode('utf-8')

    # --- Execute Command ---
    full_url = f"{base_url}{url_path}"
    headers = {
        'Content-Type': 'application/json',
        'Authorization': auth_header
    }
    
    req = request.Request(full_url, data=payload, headers=headers, method=http_method)

    print("--------------------------------------------------")
    print(f"Executing action '{args.action}' on node '{args.node}' ({ip})")
    print(f"URL: {full_url}")
    print(f"METHOD: {http_method}")
    print("--------------------------------------------------")

    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    try:
        with request.urlopen(req, context=ctx) as response:
            response_body = response.read().decode('utf-8')
            http_status = response.getcode()
            
            if response_body:
                print(json.dumps(json.loads(response_body), indent=4))

            print("--------------------------------------------------")
            print(f"Action '{args.action}' completed successfully on '{args.node}' (HTTP {http_status}).")

    except error.HTTPError as e:
        print(f"Error: Command failed on '{args.node}' with HTTP status {e.code}.", file=sys.stderr)
        if e.fp:
            print(e.fp.read().decode('utf-8'), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
