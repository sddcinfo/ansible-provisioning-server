#!/usr/bin/env python3
# =================================================================================
# A self-contained Python script to verify the functionality of the
# Ansible-configured provisioning server.
#
# This script is dynamically generated by an Ansible playbook to ensure it is
# always in sync with the inventory. It uses only standard Python 3 libraries.
# =================================================================================

import json
import socket
import subprocess
import sys
import os
from urllib import request, error

# --- Configuration ---
# This data is dynamically generated by Ansible.
PROVISIONING_NODES = {{ provisioning_nodes | to_json }}
CONSOLE_NODES = {{ console_nodes | to_json }}
SERVER_IP = "{{ server_ip }}"
DNSMASQ_DOMAIN = "{{ dnsmasq_domain }}"
# --- End Configuration ---

# --- ANSI Color Codes ---
GREEN = '\033[0;32m'
RED = '\033[0;31m'
NC = '\033[0m' # No Color

class VerificationTests:
    """A class to encapsulate all verification checks."""

    def __init__(self):
        self.failures = 0

    def _print_result(self, message, success=True):
        """Prints a formatted and colored success or failure message."""
        if success:
            print(f"{GREEN}SUCCESS:{NC} {message}")
        else:
            print(f"{RED}FAILURE:{NC} {message}")
            self.failures += 1

    def check_dns_resolution(self):
        """Verifies that all defined nodes resolve to their correct IP addresses."""
        print("\n--- Verifying DNS and DHCP ---")
        all_nodes = PROVISIONING_NODES + CONSOLE_NODES
        if not all_nodes:
            self._print_result("No nodes defined in the inventory to test.", success=False)
            return
            
        for node in all_nodes:
            hostname = node.get('hostname')
            expected_ip = node.get('ip')
            if not hostname or not expected_ip:
                self._print_result(f"Skipping node with incomplete data: {node}", success=False)
                continue
            
            try:
                # We query our own server IP, which runs dnsmasq
                actual_ip = socket.gethostbyname(f"{hostname}.{DNSMASQ_DOMAIN}")
                if actual_ip == expected_ip:
                    self._print_result(f"DNS resolution for '{hostname}' is correct ({actual_ip}).")
                else:
                    self._print_result(f"DNS resolution for '{hostname}' is incorrect. Expected {expected_ip}, got {actual_ip}.", success=False)
            except socket.gaierror:
                self._print_result(f"DNS resolution failed for '{hostname}'.", success=False)

    def check_web_services(self):
        """Verifies that the web server generates a valid iPXE script for each node."""
        print("\n--- Verifying Web Server ---")
        all_nodes = PROVISIONING_NODES + CONSOLE_NODES
        if not all_nodes:
            self._print_result("No nodes defined in the inventory to test.", success=False)
            return

        for node in all_nodes:
            mac = node.get('mac')
            if not mac:
                self._print_result(f"Skipping node with no MAC address: {node.get('hostname')}", success=False)
                continue

            url = f"http://{SERVER_IP}/?mac={mac}"
            try:
                with request.urlopen(url, timeout=5) as response:
                    content = response.read().decode('utf-8')
                    if response.getcode() == 200 and content.strip().startswith("#!ipxe"):
                        self._print_result(f"iPXE script for MAC '{mac}' is generated correctly.")
                    else:
                        self._print_result(f"iPXE script for MAC '{mac}' is invalid. Code: {response.getcode()}", success=False)
            except Exception as e:
                self._print_result(f"Failed to fetch iPXE script for MAC '{mac}': {e}", success=False)

    def check_system_services(self):
        """Verifies the status of critical system services."""
        print("\n--- Verifying Service Status ---")
        services_to_check = {
            "dnsmasq": True,
            "nginx": True,
            "php8.3-fpm": True,
            "tftpd-hpa": False,
            "systemd-resolved": False
        }
        for service, should_be_active in services_to_check.items():
            try:
                result = subprocess.run(['systemctl', 'is-active', '--quiet', service])
                is_active = result.returncode == 0
                if is_active == should_be_active:
                    status = "active" if should_be_active else "inactive"
                    self._print_result(f"Service '{service}' is correctly {status}.")
                else:
                    expected_status = "active" if should_be_active else "inactive"
                    actual_status = "active" if is_active else "inactive"
                    self._print_result(f"Service '{service}' should be {expected_status} but is {actual_status}.", success=False)
            except FileNotFoundError:
                self._print_result(f"Command 'systemctl' not found. Cannot check service '{service}'.", success=False)

    def check_network_config(self):
        """Verifies kernel parameters and firewall rules."""
        print("\n--- Verifying NAT and IP Forwarding ---")
        try:
            with open('/proc/sys/net/ipv4/ip_forward', 'r') as f:
                if f.read().strip() == '1':
                    self._print_result("Kernel IP forwarding is enabled.")
                else:
                    self._print_result("Kernel IP forwarding is not enabled.", success=False)
        except FileNotFoundError:
            self._print_result("Could not check IP forwarding status: /proc/sys/net/ipv4/ip_forward not found.", success=False)

        try:
            cmd = "iptables -t nat -C POSTROUTING -s 10.10.1.0/24 -o ens34 -j MASQUERADE -m comment --comment 'NAT for internal network'"
            subprocess.run(cmd, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self._print_result("iptables NAT rule exists.")
        except (subprocess.CalledProcessError, FileNotFoundError):
            self._print_result("iptables NAT rule does not exist.", success=False)

    def run_all_tests(self):
        """Runs all verification tests and prints a final summary."""
        self.check_dns_resolution()
        self.check_web_services()
        self.check_system_services()
        self.check_network_config()

        print("\n--- Verification Summary ---")
        if self.failures == 0:
            print(f"{GREEN}All checks passed successfully!{NC}")
            sys.exit(0)
        else:
            print(f"{RED}{self.failures} check(s) failed.{NC}")
            sys.exit(1)

if __name__ == "__main__":
    if os.geteuid() != 0:
        print("This script needs to be run with sudo to check iptables rules.")
        try:
            # Check if we can get sudo access without a password
            subprocess.check_call(['sudo', '-n', 'true'])
            # If the above command succeeds, re-run the script with sudo
            subprocess.call(['sudo', sys.executable] + sys.argv)
        except subprocess.CalledProcessError:
            # If sudo requires a password, inform the user.
            print("Sudo requires a password. Please run with 'sudo ./verify_provisioning.py'")
        sys.exit(0)
    
    tests = VerificationTests()
    tests.run_all_tests()
