#!/usr/bin/env python3

# =================================================================================
# A self-contained Python script to send Redfish commands to server nodes.
#
# This script is dynamically generated by an Ansible playbook to ensure it is
# always in sync with the inventory. It uses only standard Python 3 libraries.
# =================================================================================

import argparse
import json
import os
import ssl
import sys
from urllib import request, error
import base64
import csv

# --- Configuration ---
# This list is dynamically generated by Ansible.
CONSOLE_NODES = {{ console_nodes | to_json }}
CREDENTIALS_FILE = os.path.expanduser("~/.redfish_credentials")
# --- End Configuration ---


def get_node_ip(node_name):
    """Finds the IP address for a given node hostname."""
    for node in CONSOLE_NODES:
        if node.get("hostname") == node_name:
            return node.get("ip")
    return None


def get_redfish_credentials():
    """Reads and decodes the Basic Auth string from the credentials file."""
    if not os.path.exists(CREDENTIALS_FILE):
        print(f"Error: Credentials file not found at {CREDENTIALS_FILE}", file=sys.stderr)
        sys.exit(1)
    if os.stat(CREDENTIALS_FILE).st_mode & 0o077 != 0:
        print(f"Error: Credentials file ({CREDENTIALS_FILE}) has insecure permissions. Please set to 600.", file=sys.stderr)
        sys.exit(1)
    with open(CREDENTIALS_FILE, 'r') as f:
        content = f.read().strip()
        if content.startswith('REDFISH_AUTH="') and content.endswith('"'):
            user_pass = content.split('"')[1]
            return base64.b64encode(user_pass.encode('utf-8')).decode('utf-8')
    print(f"Error: Could not parse REDFISH_AUTH in {CREDENTIALS_FILE}", file=sys.stderr)
    sys.exit(1)


def format_as_human_readable(data, resource_type):
    """Formats a JSON response into a human-readable summary."""
    print(f"Inventory for resource '{resource_type}':")
    if resource_type == 'system':
        print(f"  - Manufacturer: {data.get('Manufacturer', 'N/A')}")
        print(f"  - Model: {data.get('Model', 'N/A')}")
        print(f"  - Serial Number: {data.get('SerialNumber', 'N/A')}")
        print(f"  - BIOS Version: {data.get('BiosVersion', 'N/A')}")
        proc_summary = data.get('ProcessorSummary', {})
        print(f"  - Processor: {proc_summary.get('Count')}x {proc_summary.get('Model', 'N/A')}")
        mem_summary = data.get('MemorySummary', {})
        print(f"  - Memory: {mem_summary.get('TotalSystemMemoryGiB')} GiB")
    elif resource_type == 'bios':
        print("  - BIOS Attributes:")
        for key, value in data.get('Attributes', {}).items():
            print(f"    - {key}: {value}")
    elif resource_type in ['memory', 'processors'] and 'Members' in data:
        print(f"  - {resource_type.capitalize()} Details:")
        if not data['Members']:
            print("    - No members found.")
            return
        for member in data['Members']:
            # To get full details, we'd need to make another call per member.
            # For a summary, we can use the @odata.id
            print(f"    - {member.get('@odata.id')}")
    else:
        print("  - No summary available for this resource. Use --format json for full details.")


def format_as_csv(data, resource_type, ip, auth_header, ctx):
    """Formats a JSON response into a flattened CSV string."""
    output = sys.stdout
    
    if resource_type in ['memory', 'processors'] and 'Members' in data:
        members_data = []
        for member in data['Members']:
            member_url = f"https://{ip}{member['@odata.id']}"
            req = request.Request(member_url, headers={'Authorization': auth_header})
            try:
                with request.urlopen(req, context=ctx) as response:
                    members_data.append(json.loads(response.read().decode('utf-8')))
            except Exception:
                continue

        if not members_data:
            print("Could not retrieve any member details.")
            return

        if resource_type == 'memory':
            fieldnames = ['Socket', 'Name', 'CapacityMiB', 'Manufacturer', 'PartNumber', 'SerialNumber', 'StatusState']
            writer = csv.DictWriter(output, fieldnames=fieldnames, extrasaction='ignore')
            writer.writeheader()
            for member_data in members_data:
                row = {
                    'Socket': member_data.get('Socket'),
                    'Name': member_data.get('Name'),
                    'CapacityMiB': member_data.get('CapacityMiB'),
                    'Manufacturer': member_data.get('Manufacturer'),
                    'PartNumber': member_data.get('PartNumber'),
                    'SerialNumber': member_data.get('SerialNumber'),
                    'StatusState': member_data.get('Status', {}).get('State')
                }
                writer.writerow(row)
        elif resource_type == 'processors':
            fieldnames = ['Socket', 'Model', 'TotalCores', 'TotalThreads', 'ProcessorArchitecture', 'InstructionSet', 'Manufacturer', 'StatusState']
            writer = csv.DictWriter(output, fieldnames=fieldnames, extrasaction='ignore')
            writer.writeheader()
            for member_data in members_data:
                row = {
                    'Socket': member_data.get('Socket'),
                    'Model': member_data.get('Model'),
                    'TotalCores': member_data.get('TotalCores'),
                    'TotalThreads': member_data.get('TotalThreads'),
                    'ProcessorArchitecture': member_data.get('ProcessorArchitecture'),
                    'InstructionSet': member_data.get('InstructionSet'),
                    'Manufacturer': member_data.get('Manufacturer'),
                    'StatusState': member_data.get('Status', {}).get('State')
                }
                writer.writerow(row)
    else:
        flat_data = {}
        def flatten(x, name=''):
            if type(x) is dict:
                for a in x:
                    flatten(x[a], name + a + '_')
            elif type(x) is list:
                i = 0
                for a in x:
                    flatten(a, name + str(i) + '_')
                    i += 1
            else:
                flat_data[name[:-1]] = x
        flatten(data)
        if flat_data:
            writer = csv.DictWriter(output, fieldnames=flat_data.keys())
            writer.writeheader()
            writer.writerow(flat_data)


def print_output(node_name, action, response_body, http_status, args, ip, auth_header, ctx):
    """Prints a formatted output based on the verbosity level and action."""
    verbose = args.verbose
    output_format = getattr(args, 'format', None)

    if verbose:
        print("--------------------------------------------------")
        print(f"Verbose output for '{node_name}':")
        if response_body:
            print(json.dumps(json.loads(response_body), indent=4))
        print(f"Action '{action}' completed successfully (HTTP {http_status}).")
        return

    if not response_body:
        print(f"{node_name}: Action '{action}' completed successfully.")
        return

    data = json.loads(response_body)
    if action == 'inventory':
        if output_format == 'csv':
            format_as_csv(data, args.resource, ip, auth_header, ctx)
        elif output_format == 'json':
            print(json.dumps(data, indent=4))
        else: # Default to human-readable
            format_as_human_readable(data, args.resource)
    elif action == 'status':
        power = data.get('PowerState', 'Unknown')
        health = data.get('Status', {}).get('Health', 'Unknown')
        print(f"{node_name}: Power={power}, Health={health}")
    elif action == 'sensors':
        sensor_type = getattr(args, 'type', None)
        sensor_name = getattr(args, 'name', None)
        print(f"Sensor status for '{node_name}':")
        name_filter = sensor_name.lower() if sensor_name else None
        found_sensor = False
        if not sensor_type or sensor_type == 'temperature':
            for temp in data.get('Temperatures', []):
                name = temp.get('Name', 'N/A')
                if name_filter and name_filter not in name.lower():
                    continue
                found_sensor = True
                reading = temp.get('ReadingCelsius', 'N/A')
                status = temp.get('Status', {}).get('Health', 'N/A')
                print(f"  - Temp: {name}: {reading}Â°C (Status: {status})")
        if not sensor_type or sensor_type == 'fan':
            for fan in data.get('Fans', []):
                name = fan.get('FanName', 'N/A')
                if name_filter and name_filter not in name.lower():
                    continue
                found_sensor = True
                reading = fan.get('Reading', 'N/A')
                units = fan.get('ReadingUnits', '')
                status = fan.get('Status', {}).get('Health', 'N/A')
                print(f"  - Fan: {name}: {reading} {units} (Status: {status})")
        if not found_sensor:
            print("  - No matching sensors found.")
    else:
        print(f"{node_name}: Action '{action}' completed successfully.")


def execute_redfish_command(node_name, args):
    """Executes a single Redfish command against a single node."""
    ip = get_node_ip(node_name)
    if not ip:
        print(f"Error: Node '{node_name}' not found. Skipping.", file=sys.stderr)
        return

    auth_header = f"Basic {get_redfish_credentials()}"
    action = args.action

    base_urls = {
        "system": f"https://{ip}/redfish/v1/Systems/1",
        "chassis": f"https://{ip}/redfish/v1/Chassis/1"
    }
    
    base_url = base_urls["system"]
    url_path = ""
    http_method = "GET"
    payload = None

    actions = {
        "status": {"method": "GET", "base": "system"},
        "sensors": {"method": "GET", "base": "chassis", "path": "/Thermal"},
        "inventory": {"method": "GET", "base": "system"},
        "power-on": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "On"}},
        "power-off": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "GracefulShutdown"}},
        "power-force-off": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "ForceOff"}},
        "reboot": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "ForceRestart"}},
        "bios": {"base": "system", "method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "BiosSetup", "BootSourceOverrideEnabled": "Once"}}},
        "pxe": {"base": "system", "method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "Pxe", "BootSourceOverrideEnabled": "Once"}}},
        "disk": {"base": "system", "method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "Hdd", "BootSourceOverrideEnabled": "Once"}}},
    }

    inventory_paths = {
        "system": "", "bios": "/Bios", "memory": "/Memory", 
        "processors": "/Procesors", "storage": "/Storage"
    }

    action_details = actions.get(action)
    http_method = action_details.get("method", "POST")
    base_url = base_urls.get(action_details.get("base", "system"))
    url_path = action_details.get("path", "")
    
    if action == 'inventory':
        http_method = "GET"
        url_path = inventory_paths.get(args.resource, "")
    elif "payload" in action_details:
        payload = json.dumps(action_details["payload"]).encode('utf-8')

    full_url = f"{base_url}{url_path}"
    headers = {'Content-Type': 'application/json', 'Authorization': auth_header}
    req = request.Request(full_url, data=payload, headers=headers, method=http_method)

    if args.verbose:
        print("--------------------------------------------------")
        print(f"Executing action '{action}' on node '{node_name}' ({ip})")
        print(f"URL: {full_url}")
        print(f"METHOD: {http_method}")

    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    try:
        with request.urlopen(req, context=ctx) as response:
            response_body = response.read().decode('utf-8')
            http_status = response.getcode()
            print_output(node_name, action, response_body, http_status, args, ip, auth_header, ctx)

    except error.HTTPError as e:
        print("--------------------------------------------------")
        print(f"Error: Command failed on '{node_name}' with HTTP status {e.code}.", file=sys.stderr)
        if e.fp:
            print(e.fp.read().decode('utf-8'), file=sys.stderr)
    except Exception as e:
        print("--------------------------------------------------")
        print(f"An unexpected error occurred on node '{node_name}': {e}", file=sys.stderr)


def main():
    """Main function to parse arguments and execute Redfish command."""
    if len(sys.argv) == 1:
        print("Usage: ./redfish.py <nodes> <action> [options]")
        print("\nThis script requires a node name (or a comma-separated list) and an action.")
        print("\nCommon Examples:")
        print("  ./redfish.py console-node1 status")
        print("  ./redfish.py console-node1,console-node2 reboot")
        print("  ./redfish.py console-node1 sensors --type temperature")
        print("  ./redfish.py console-node1 inventory --resource memory")
        print("  ./redfish.py console-node1 inventory --resource memory --format csv")
        print("\nUse -h or --help for a full list of actions and options.")
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="A script to send Redfish commands to one or more server nodes.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("nodes", help="A single node name or a comma-separated list of node names.")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output for debugging.")

    subparsers = parser.add_subparsers(dest="action", required=True, metavar='action')

    simple_actions = ["status", "power-on", "power-off", "power-force-off", "reboot", "bios", "pxe", "disk"]
    for action in simple_actions:
        subparsers.add_parser(action, help=f"{action.capitalize()} the node(s).")

    parser_sensors = subparsers.add_parser("sensors", help="Get temperature and fan sensor readings.")
    parser_sensors.add_argument("--type", choices=["temperature", "fan"], help="Filter by sensor type.")
    parser_sensors.add_argument("--name", help="Filter sensors by a case-insensitive name.")
    
    parser_inventory = subparsers.add_parser("inventory", help="Get detailed hardware inventory.")
    parser_inventory.add_argument("--resource", choices=["system", "bios", "memory", "processors", "storage"], required=True, help="The hardware resource to query.")
    parser_inventory.add_argument("--format", choices=["json", "csv"], help="Specify the output format (default: human-readable summary).")
    
    args = parser.parse_args()

    node_list = [node.strip() for node in args.nodes.split(',')]

    for node_name in node_list:
        execute_redfish_command(node_name, args)


if __name__ == "__main__":
    main()