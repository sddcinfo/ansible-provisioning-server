#!/usr/bin/env python3

# =================================================================================
# A self-contained Python script to send Redfish commands to server nodes.
#
# This script is dynamically generated by an Ansible playbook to ensure it is
# always in sync with the inventory. It uses only standard Python 3 libraries.
# =================================================================================

import argparse
import json
import os
import ssl
import sys
from urllib import request, error
import base64
import csv
import io

# --- Configuration ---
# This list is dynamically generated by Ansible.
CONSOLE_NODES = {{ console_nodes | to_json }}
CREDENTIALS_FILE = os.path.expanduser("~/.redfish_credentials")
# --- End Configuration ---


def get_node_ip(node_name):
    """Finds the IP address for a given node hostname."""
    for node in CONSOLE_NODES:
        if node.get("hostname") == node_name:
            return node.get("ip")
    return None


def get_redfish_credentials():
    """Reads and decodes the Basic Auth string from the credentials file."""
    if not os.path.exists(CREDENTIALS_FILE):
        print(f"Error: Credentials file not found at {CREDENTIALS_FILE}", file=sys.stderr)
        sys.exit(1)
    if os.stat(CREDENTIALS_FILE).st_mode & 0o077 != 0:
        print(f"Error: Credentials file ({CREDENTIALS_FILE}) has insecure permissions. Please set to 600.", file=sys.stderr)
        sys.exit(1)
    with open(CREDENTIALS_FILE, 'r') as f:
        content = f.read().strip()
        if content.startswith('REDFISH_AUTH="') and content.endswith('"'):
            user_pass = content.split('"')[1]
            return base64.b64encode(user_pass.encode('utf-8')).decode('utf-8')
    print(f"Error: Could not parse REDFISH_AUTH in {CREDENTIALS_FILE}", file=sys.stderr)
    sys.exit(1)


def format_as_csv(data, resource_type):
    """Formats a JSON response into a flattened CSV string."""
    output = io.StringIO()
    writer = None

    if resource_type == 'sensors' and ('Temperatures' in data or 'Fans' in data):
        fieldnames = ['SensorType', 'Name', 'Reading', 'Units', 'Status']
        writer = csv.DictWriter(output, fieldnames=fieldnames)
        writer.writeheader()
        for temp in data.get('Temperatures', []):
            writer.writerow({
                'SensorType': 'Temperature', 'Name': temp.get('Name'),
                'Reading': temp.get('ReadingCelsius'), 'Units': 'C',
                'Status': temp.get('Status', {}).get('Health')
            })
        for fan in data.get('Fans', []):
            writer.writerow({
                'SensorType': 'Fan', 'Name': fan.get('FanName'),
                'Reading': fan.get('Reading'), 'Units': fan.get('ReadingUnits'),
                'Status': fan.get('Status', {}).get('Health')
            })
    else:
        # Generic flatten for other resources
        flat_data = {}
        def flatten(x, name=''):
            if type(x) is dict:
                for a in x: flatten(x[a], name + a + '_')
            else: flat_data[name[:-1]] = x
        flatten(data)
        if flat_data:
            writer = csv.DictWriter(output, fieldnames=flat_data.keys())
            writer.writeheader()
            writer.writerow(flat_data)
    
    return output.getvalue()


def format_as_human_readable(data, resource_type):
    """Formats a JSON response into a human-readable summary."""
    output = [f"Inventory for resource '{resource_type}':"]
    if resource_type == 'system':
        output.append(f"  - Manufacturer: {data.get('Manufacturer', 'N/A')}")
        output.append(f"  - Model: {data.get('Model', 'N/A')}")
        output.append(f"  - Serial Number: {data.get('SerialNumber', 'N/A')}")
    elif resource_type in ['memory', 'processors'] and 'Members' in data:
        output.append(f"  - {resource_type.capitalize()} Details:")
        for member in data.get('Members', []):
            output.append(f"    - {member.get('@odata.id')}")
    return "\n".join(output)


def process_response(node_name, action, response_body, http_status, args):
    """Processes the response and returns formatted output string."""
    output_format = getattr(args, 'format', None)
    json_output = getattr(args, 'json', False)

    if not response_body:
        return f"{node_name}: Action '{action}' completed successfully."

    data = json.loads(response_body)
    
    if output_format == 'json' or json_output:
        return json.dumps(data, indent=4)
    elif output_format == 'csv':
        return format_as_csv(data, action if action == 'sensors' else args.resource)

    # Default to human-readable output
    if action == 'inventory':
        return format_as_human_readable(data, args.resource)
    elif action == 'status':
        power = data.get('PowerState', 'Unknown')
        health = data.get('Status', {}).get('Health', 'Unknown')
        return f"{node_name}: Power={power}, Health={health}"
    elif action == 'sensors':
        sensor_type = getattr(args, 'type', None)
        sensor_name = getattr(args, 'name', None)
        filter_name = getattr(args, 'filter', None)
        output = [f"Sensor status for '{node_name}':"]
        name_filter = (sensor_name or filter_name).lower() if (sensor_name or filter_name) else None
        found_sensor = False
        if not sensor_type or sensor_type == 'temperature':
            for temp in data.get('Temperatures', []):
                name = temp.get('Name', 'N/A')
                if name_filter and name_filter not in name.lower(): continue
                found_sensor = True
                output.append(f"  - Temp: {temp.get('Name', 'N/A')}: {temp.get('ReadingCelsius', 'N/A')}Â°C (Status: {temp.get('Status', {}).get('Health', 'N/A')})")
        if not sensor_type or sensor_type == 'fan':
            for fan in data.get('Fans', []):
                name = fan.get('FanName', 'N/A')
                if name_filter and name_filter not in name.lower(): continue
                found_sensor = True
                output.append(f"  - Fan: {fan.get('FanName', 'N/A')}: {fan.get('Reading', 'N/A')} {fan.get('ReadingUnits', '')} (Status: {fan.get('Status', {}).get('Health', 'N/A')})")
        if not found_sensor:
            output.append("  - No matching sensors found.")
        return "\n".join(output)
    else:
        return f"{node_name}: Action '{action}' completed successfully."


def build_request(node_name, args):
    """Builds the Redfish request object based on the provided arguments."""
    ip = get_node_ip(node_name)
    if not ip:
        return None, None

    action = args.action
    base_urls = {"system": f"https://{ip}/redfish/v1/Systems/1", "chassis": f"https://{ip}/redfish/v1/Chassis/1"}
    inventory_paths = {"system": "", "bios": "/Bios", "memory": "/Memory", "processors": "/Processors", "storage": "/Storage"}
    actions = {
        "status": {"method": "GET", "base": "system"},
        "sensors": {"method": "GET", "base": "chassis", "path": "/Thermal"},
        "inventory": {"method": "GET", "base": "system"},
        "power-on": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "On"}},
        "power-off": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "GracefulShutdown"}},
        "power-reboot": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "GracefulRestart"}},
        "power-cycle": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "ForceRestart"}},
        "set-boot-to-bios": {"method": "PATCH", "base": "system", "payload": {"Boot": {"BootSourceOverrideTarget": "BiosSetup"}}},
        "reboot": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "ForceRestart"}},
    }

    action_details = actions.get(action, {})
    http_method = action_details.get("method", "POST")
    base_url = base_urls.get(action_details.get("base", "system"))
    
    if action == 'inventory':
        url_path = inventory_paths.get(args.resource, "")
    else:
        url_path = action_details.get("path", "")
        
    payload = json.dumps(action_details["payload"]).encode('utf-8') if "payload" in action_details else None
    
    return request.Request(f"{base_url}{url_path}", data=payload, headers={'Content-Type': 'application/json'}, method=http_method), ip


def execute_redfish_command(node_name, args):
    """Executes a single Redfish command against a single node."""
    req, ip = build_request(node_name, args)
    if not req:
        print(f"Error: Node '{node_name}' not found. Skipping.", file=sys.stderr)
        return

    auth_header = f"Basic {get_redfish_credentials()}"
    req.add_header("Authorization", auth_header)

    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    try:
        with request.urlopen(req, context=ctx) as response:
            response_body = response.read().decode('utf-8')
            http_status = response.getcode()
            output = process_response(node_name, args.action, response_body, http_status, args)
            print(output)

    except error.HTTPError as e:
        print(f"Error: Command failed on '{node_name}' with HTTP status {e.code}.", file=sys.stderr)
    except Exception as e:
        print(f"An unexpected error occurred on node '{node_name}': {e}", file=sys.stderr)


def create_parser():
    """Creates and returns the argument parser."""
    parser = argparse.ArgumentParser(description="A script to send Redfish commands to server nodes.", formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("nodes", nargs='?', default="", help="A single node name or a comma-separated list of node names.")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output for debugging.")
    subparsers = parser.add_subparsers(dest="action", metavar='action')

    actions_list = ["status", "power-on", "power-off", "power-reboot", "power-cycle", "set-boot-to-bios", "reboot"]
    for action in actions_list:
        subparsers.add_parser(action)

    parser_sensors = subparsers.add_parser("sensors")
    parser_sensors.add_argument("--type", choices=["temperature", "fan"])
    parser_sensors.add_argument("--name")
    parser_sensors.add_argument("--filter", help="Filter sensors by name (case-insensitive substring)")
    parser_sensors.add_argument("--format", choices=["json", "csv"])
    parser_sensors.add_argument("--json", action="store_true", help="Output result in JSON format (alias for --format json)")
    
    parser_inventory = subparsers.add_parser("inventory")
    parser_inventory.add_argument("--resource", choices=["system", "bios", "memory", "processors", "storage"], required=True)
    parser_inventory.add_argument("--format", choices=["json", "csv"])
    
    return parser


def main():
    """Main function to parse arguments and execute Redfish command."""
    if len(sys.argv) < 2 or (len(sys.argv) > 1 and sys.argv[1] in ['-h', '--help']):
        parser = create_parser()
        parser.print_help()
        sys.exit(0)
    
    if len(sys.argv) < 3:
        print("Usage: ./redfish.py <nodes> <action> [options]")
        print("\nError: Missing nodes and/or action arguments.")
        sys.exit(1)

    parser = create_parser()
    args = parser.parse_args()

    node_list = [node.strip() for node in args.nodes.split(',')]

    for node_name in node_list:
        execute_redfish_command(node_name, args)


if __name__ == "__main__":
    main()
