#!/usr/bin/env python3

# =================================================================================
# A self-contained Python script to send Redfish commands to server nodes.
#
# This script is dynamically generated by an Ansible playbook to ensure it is
# always in sync with the inventory. It uses only standard Python 3 libraries.
# =================================================================================

import argparse
import json
import os
import ssl
import sys
from urllib import request, error
import base64

# --- Configuration ---
# This list is dynamically generated by Ansible.
CONSOLE_NODES = {{ console_nodes | to_json }}
CREDENTIALS_FILE = os.path.expanduser("~/.redfish_credentials")
# --- End Configuration ---


def get_node_ip(node_name):
    """Finds the IP address for a given node hostname."""
    for node in CONSOLE_NODES:
        if node.get("hostname") == node_name:
            return node.get("ip")
    return None


def get_redfish_credentials():
    """Reads and decodes the Basic Auth string from the credentials file."""
    if not os.path.exists(CREDENTIALS_FILE):
        print(f"Error: Credentials file not found at {CREDENTIALS_FILE}", file=sys.stderr)
        sys.exit(1)
    if os.stat(CREDENTIALS_FILE).st_mode & 0o077 != 0:
        print(f"Error: Credentials file ({CREDENTIALS_FILE}) has insecure permissions. Please set to 600.", file=sys.stderr)
        sys.exit(1)
    with open(CREDENTIALS_FILE, 'r') as f:
        content = f.read().strip()
        if content.startswith('REDFISH_AUTH="') and content.endswith('"'):
            user_pass = content.split('"')[1]
            return base64.b64encode(user_pass.encode('utf-8')).decode('utf-8')
    print(f"Error: Could not parse REDFISH_AUTH in {CREDENTIALS_FILE}", file=sys.stderr)
    sys.exit(1)


def print_output(node_name, action, response_body, http_status, verbose=False, sensor_type=None, sensor_name=None):
    """Prints a formatted output based on the verbosity level and action."""
    if verbose:
        print("--------------------------------------------------")
        print(f"Verbose output for '{node_name}':")
        if response_body:
            print(json.dumps(json.loads(response_body), indent=4))
        print(f"Action '{action}' completed successfully (HTTP {http_status}).")
        return

    if not response_body:
        print(f"{node_name}: Action '{action}' completed successfully.")
        return

    data = json.loads(response_body)
    if action == 'status':
        power = data.get('PowerState', 'Unknown')
        health = data.get('Status', {}).get('Health', 'Unknown')
        print(f"{node_name}: Power={power}, Health={health}")
    elif action == 'sensors':
        print(f"Sensor status for '{node_name}':")
        name_filter = sensor_name.lower() if sensor_name else None
        found_sensor = False

        if not sensor_type or sensor_type == 'temperature':
            for temp in data.get('Temperatures', []):
                name = temp.get('Name', 'N/A')
                if name_filter and name_filter not in name.lower():
                    continue
                found_sensor = True
                reading = temp.get('ReadingCelsius', 'N/A')
                status = temp.get('Status', {}).get('Health', 'N/A')
                print(f"  - Temp: {name}: {reading}Â°C (Status: {status})")
        
        if not sensor_type or sensor_type == 'fan':
            for fan in data.get('Fans', []):
                name = fan.get('FanName', 'N/A')
                if name_filter and name_filter not in name.lower():
                    continue
                found_sensor = True
                reading = fan.get('Reading', 'N/A')
                units = fan.get('ReadingUnits', '')
                status = fan.get('Status', {}).get('Health', 'N/A')
                print(f"  - Fan: {name}: {reading} {units} (Status: {status})")
        
        if not found_sensor:
            print("  - No matching sensors found.")
    else:
        print(f"{node_name}: Action '{action}' completed successfully.")


def execute_redfish_command(node_name, args):
    """Executes a single Redfish command against a single node."""
    ip = get_node_ip(node_name)
    if not ip:
        print(f"Error: Node '{node_name}' not found. Skipping.", file=sys.stderr)
        return

    auth_header = f"Basic {get_redfish_credentials()}"
    action = args.action

    base_urls = {
        "system": f"https://{ip}/redfish/v1/Systems/1",
        "chassis": f"https://{ip}/redfish/v1/Chassis/1"
    }
    
    base_url = base_urls["system"]
    url_path = ""
    http_method = "GET"
    payload = None

    actions = {
        "status": {"method": "GET", "base": "system"},
        "sensors": {"method": "GET", "base": "chassis", "path": "/Thermal"},
        "power-on": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "On"}},
        "power-off": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "GracefulShutdown"}},
        "power-force-off": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "ForceOff"}},
        "reboot": {"base": "system", "path": "/Actions/ComputerSystem.Reset", "payload": {"ResetType": "ForceRestart"}},
        "bios": {"base": "system", "method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "BiosSetup", "BootSourceOverrideEnabled": "Once"}}},
        "pxe": {"base": "system", "method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "Pxe", "BootSourceOverrideEnabled": "Once"}}},
        "disk": {"base": "system", "method": "PATCH", "payload": {"Boot": {"BootSourceOverrideTarget": "Hdd", "BootSourceOverrideEnabled": "Once"}}},
    }

    action_details = actions.get(action)
    http_method = action_details.get("method", "POST")
    base_url = base_urls.get(action_details.get("base", "system"))
    url_path = action_details.get("path", "")
    if "payload" in action_details:
        payload = json.dumps(action_details["payload"]).encode('utf-8')

    full_url = f"{base_url}{url_path}"
    headers = {'Content-Type': 'application/json', 'Authorization': auth_header}
    req = request.Request(full_url, data=payload, headers=headers, method=http_method)

    if args.verbose:
        print("--------------------------------------------------")
        print(f"Executing action '{action}' on node '{node_name}' ({ip})")
        print(f"URL: {full_url}")
        print(f"METHOD: {http_method}")

    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    try:
        with request.urlopen(req, context=ctx) as response:
            response_body = response.read().decode('utf-8')
            http_status = response.getcode()
            sensor_type = getattr(args, 'type', None)
            sensor_name = getattr(args, 'name', None)
            print_output(node_name, action, response_body, http_status, args.verbose, sensor_type, sensor_name)

    except error.HTTPError as e:
        print("--------------------------------------------------")
        print(f"Error: Command failed on '{node_name}' with HTTP status {e.code}.", file=sys.stderr)
        if e.fp:
            print(e.fp.read().decode('utf-8'), file=sys.stderr)
    except Exception as e:
        print("--------------------------------------------------")
        print(f"An unexpected error occurred on node '{node_name}': {e}", file=sys.stderr)


def main():
    """Main function to parse arguments and execute Redfish command."""
    if len(sys.argv) == 1:
        print("Usage: ./redfish.py <nodes> <action> [options]")
        print("\nThis script requires a node name (or a comma-separated list) and an action.")
        print("\nCommon Examples:")
        print("  ./redfish.py console-node1 status")
        print("  ./redfish.py console-node1,console-node2 reboot")
        print("  ./redfish.py console-node1 sensors")
        print("  ./redfish.py console-node1 sensors --type temperature")
        print("  ./redfish.py console-node1 sensors --type temperature --name \"CPU\"")
        print("\nUse -h or --help for a full list of actions and options.")
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="A script to send Redfish commands to one or more server nodes.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("nodes", help="A single node name or a comma-separated list of node names (e.g., 'console-node1' or 'console-node1,console-node2').")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output for debugging.")

    subparsers = parser.add_subparsers(dest="action", required=True, metavar='action', help="The action to perform.")

    # Help text for simple actions
    simple_actions_help = {
        "status": "Get system power state and health status.",
        "power-on": "Power the system on.",
        "power-off": "Power the system off gracefully.",
        "power-force-off": "Force the system to power off immediately.",
        "reboot": "Perform a force restart of the node.",
        "bios": "Set the node to boot into BIOS setup on the next restart.",
        "pxe": "Set the node to boot from PXE on the next restart.",
        "disk": "Set the node to boot from the default disk on the next restart."
    }
    for action, help_text in simple_actions_help.items():
        subparsers.add_parser(action, help=help_text)

    # Help text for the 'sensors' action
    parser_sensors = subparsers.add_parser("sensors", help="Get temperature and fan sensor readings.", formatter_class=argparse.RawTextHelpFormatter)
    parser_sensors.add_argument("--type", choices=["temperature", "fan"], help="Filter by sensor type (e.g., 'temperature' or 'fan').")
    parser_sensors.add_argument("--name", help="Filter sensors by a case-insensitive name (e.g., 'CPU', 'System').")
    
    args = parser.parse_args()

    node_list = [node.strip() for node in args.nodes.split(',')]

    for node_name in node_list:
        execute_redfish_command(node_name, args)


if __name__ == "__main__":
    main()
